<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jason's 4x4 Puzzle (2025)</title>
  <meta name="description" content="Jason's 4x4 sliding puzzle with 10 endangered animals (2025)" />
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{height:100%}
  </style>
</head>
<body class="bg-slate-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const fmtTime = (ms) => {
      const total = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    };

    function playVictoryMelody() {
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioCtx();
        const notes = [
          { f: 523.25, t: 0.0, d: 0.18 },
          { f: 659.25, t: 0.2, d: 0.18 },
          { f: 783.99, t: 0.4, d: 0.18 },
          { f: 1046.5, t: 0.6, d: 0.24 },
          { f: 987.77, t: 0.88, d: 0.16 },
          { f: 1046.5, t: 1.06, d: 0.4 },
        ];
        const master = ctx.createGain(); master.gain.value = 0.08; master.connect(ctx.destination);
        notes.forEach((n) => {
          const osc = ctx.createOscillator(); const g = ctx.createGain();
          osc.type = "triangle"; osc.frequency.value = n.f; osc.connect(g); g.connect(master);
          const start = ctx.currentTime + n.t; const end = start + n.d;
          g.gain.setValueAtTime(0, start); g.gain.linearRampToValueAtTime(1, start + 0.02);
          g.gain.exponentialRampToValueAtTime(0.0001, end); osc.start(start); osc.stop(end + 0.01);
        });
        setTimeout(() => ctx.close(), 2200);
      } catch (e) {}
    }

    // --- Watercolor-ready SVG wrapper (soft noise, paper texture, gradients) ---
    const svgWrapper = (inner, bg1 = "#F5F7FB", bg2 = "#FFFFFF") => `<?xml version='1.0' encoding='UTF-8'?>
    <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 600'>
      <defs>
        <linearGradient id='bg' x1='0' y1='0' x2='1' y2='1'>
          <stop offset='0%' stop-color='${bg1}'/>
          <stop offset='100%' stop-color='${bg2}'/>
        </linearGradient>
        <filter id='paper' x='-20%' y='-20%' width='140%' height='140%'>
          <feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='2' result='noise'/>
          <feColorMatrix type='saturate' values='0.5'/>
          <feBlend in='SourceGraphic' in2='noise' mode='multiply'/>
          <feGaussianBlur stdDeviation='0.3'/>
        </filter>
        <filter id='soft' x='-20%' y='-20%' width='140%' height='140%'><feDropShadow dx='0' dy='3' stdDeviation='5' flood-color='#c7cdda' flood-opacity='0.5'/></filter>
      </defs>
      <rect x='0' y='0' width='600' height='600' fill='url(#bg)'/>
      <g filter='url(#paper)'>${inner}</g>
    </svg>`;

    const toDataUrl = (svg) => `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svg)))}`;

    const eyesCheeks = (cx1, cx2, cy, cheekY, colorEye = "#2B2D42") => `
      <g>\n
        <circle cx='${cx1}' cy='${cy}' r='18' fill='${colorEye}'/>\n
        <circle cx='${cx2}' cy='${cy}' r='18' fill='${colorEye}'/>\n
        <circle cx='${cx1-5}' cy='${cy-5}' r='5' fill='#fff' opacity='0.9'/>\n
        <circle cx='${cx2-5}' cy='${cy-5}' r='5' fill='#fff' opacity='0.9'/>\n
        <circle cx='${cx1}' cy='${cheekY}' r='10' fill='#FFADB0' opacity='0.7'/>\n
        <circle cx='${cx2}' cy='${cheekY}' r='10' fill='#FFADB0' opacity='0.7'/>\n
      </g>`;

    // --- Animals (more detailed, watercolor-friendly) ---
    const svgPangolin = () => svgWrapper(`
      <g filter='url(#soft)'>
        <radialGradient id='pg1' cx='50%' cy='40%' r='50%'>
          <stop offset='0%' stop-color='#E8C5AF'/>
          <stop offset='100%' stop-color='#C79D87'/>
        </radialGradient>
        <ellipse cx='300' cy='360' rx='230' ry='170' fill='url(#pg1)'/>\n
        ${Array.from({length:24}).map((_,i)=>{
          const row=Math.floor(i/8), col=i%8; const x=140+col*45; const y=250+row*35;
          const c= row%2? '#B88973':'#D7B9A7';
          return `<path d='M${x} ${y} h44 l-22 26 z' fill='${c}' opacity='0.95'/>`;
        }).join('')}\n
        ${eyesCheeks(260,340,310,335)}\n
        <ellipse cx='300' cy='355' rx='26' ry='18' fill='#444'/>\n
      </g>
    `, "#F8EFE7", "#FFF7F1");

    const svgAmurLeopard = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <radialGradient id='al1' cx='50%' cy='40%' r='50%'>\n
          <stop offset='0%' stop-color='#FFD98A'/>\n
          <stop offset='100%' stop-color='#FFBF5E'/>\n
        </radialGradient>\n
        <ellipse cx='300' cy='360' rx='220' ry='170' fill='url(#al1)'/>\n
        <ellipse cx='300' cy='310' rx='150' ry='110' fill='#FFC24D' opacity='0.9'/>\n
        ${eyesCheeks(260,340,300,325)}\n
        <ellipse cx='300' cy='340' rx='25' ry='18' fill='#444'/>\n
        ${Array.from({length:18}).map((_,i)=>{ const ang=(i/18)*Math.PI*2; const r=120; const x=300+Math.cos(ang)*r; const y=320+Math.sin(ang)*r; return `<circle cx='${x}' cy='${y}' r='12' fill='#8C5A2F'/>`;}).join('')}\n
      </g>
    `, "#FFF3D6", "#FFFFFF");

    const svgJavanRhino = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='jr1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#C7D1DA'/>\n
          <stop offset='100%' stop-color='#9FB0BC'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='230' ry='160' fill='url(#jr1)'/>\n
        <ellipse cx='300' cy='320' rx='160' ry='110' fill='#A0AFBA' opacity='0.9'/>\n
        <path d='M340 280 l40 -40 l10 30 z' fill='#EDE7D9'/>\n
        ${eyesCheeks(260,340,310,335,\"#2b2d42\")}\n
        <ellipse cx='300' cy='355' rx='28' ry='20' fill='#444'/>\n
      </g>
    `, "#E6EEF5", "#FFFFFF");

    const svgVaquita = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='vq1' x1='0' y1='0' x2='0' y2='1'>\n
          <stop offset='0%' stop-color='#BFE7F7'/>\n
          <stop offset='100%' stop-color='#8AC7E4'/>\n
        </linearGradient>\n
        <rect x='80' y='240' width='440' height='200' rx='30' fill='url(#vq1)'/>\n
        ${eyesCheeks(260,340,310,335,\"#1f2937\")}\n
        <ellipse cx='300' cy='355' rx='26' ry='18' fill='#374151'/>\n
      </g>
    `, "#E8F7FF", "#FFFFFF");

    const svgKakapo = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='kp1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#D9F2B8'/>\n
          <stop offset='100%' stop-color='#BEE691'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='210' ry='170' fill='url(#kp1)'/>\n
        <ellipse cx='300' cy='330' rx='160' ry='120' fill='#B4D98A' opacity='0.9'/>\n
        ${eyesCheeks(260,340,310,335)}\n
      </g>\n
    `, "#F3F9EC", "#FFFFFF");

    const svgOrangutan = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='ou1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#F4B890'/>\n
          <stop offset='100%' stop-color='#E59A63'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='230' ry='170' fill='url(#ou1)'/>\n
        ${eyesCheeks(260,340,305,330)}\n
        <ellipse cx='300' cy='350' rx='28' ry='20' fill='#444'/>\n
      </g>\n
    `, "#FFF5EE", "#FFFFFF");

    const svgSaola = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='sl1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#E2D6C7'/>\n
          <stop offset='100%' stop-color='#C9B9A6'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='220' ry='160' fill='url(#sl1)'/>\n
        <rect x='280' y='180' width='8' height='100' fill='#3B3B3B'/>\n
        <rect x='312' y='180' width='8' height='100' fill='#3B3B3B'/>\n
        ${eyesCheeks(260,340,310,335)}\n
        <ellipse cx='300' cy='355' rx='26' ry='18' fill='#444'/>\n
      </g>\n
    `, "#F7EFE6", "#FFFFFF");

    const svgHawksbill = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='hb1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#B8F0DF'/>\n
          <stop offset='100%' stop-color='#8DD7C1'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='210' ry='160' fill='url(#hb1)'/>\n
        ${Array.from({length:10}).map((_,i)=>{ const x=220+(i%5)*40; const y=290+Math.floor(i/5)*40; return `<rect x='${x}' y='${y}' width='32' height='24' rx='6' fill='#6DB6A1'/>`;}).join('')}\n
        ${eyesCheeks(260,340,310,335,\"#1f2937\")}\n
      </g>\n
    `, "#E9FBF6", "#FFFFFF");

    const svgGorilla = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='gl1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#C6CCD6'/>\n
          <stop offset='100%' stop-color='#9DA5B1'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='230' ry='170' fill='url(#gl1)'/>\n
        ${eyesCheeks(260,340,305,330,\"#111827\")}\n
        <ellipse cx='300' cy='350' rx='30' ry='22' fill='#111827'/>\n
      </g>\n
    `, "#F1F3F6", "#FFFFFF");

    const svgPhilippineEagle = () => svgWrapper(`
      <g filter='url(#soft)'>\n
        <linearGradient id='pe1' x1='0' y1='0' x2='1' y2='1'>\n
          <stop offset='0%' stop-color='#F0E9DD'/>\n
          <stop offset='100%' stop-color='#D9CFBF'/>\n
        </linearGradient>\n
        <ellipse cx='300' cy='360' rx='210' ry='160' fill='url(#pe1)'/>\n
        ${eyesCheeks(260,340,300,325,\"#1f2937\")}\n
        <path d='M300 330 l25 30 h-50 z' fill='#F5D78A'/>\n
      </g>\n
    `, "#F7F3EC", "#FFFFFF");

    const ANIMALS = [
      { name: "Amur Leopard", maker: svgAmurLeopard },
      { name: "Javan Rhino", maker: svgJavanRhino },
      { name: "Vaquita", maker: svgVaquita },
      { name: "Kakapo", maker: svgKakapo },
      { name: "Sumatran Orangutan", maker: svgOrangutan },
      { name: "Saola", maker: svgSaola },
      { name: "Hawksbill Sea Turtle", maker: svgHawksbill },
      { name: "Mountain Gorilla", maker: svgGorilla },
      { name: "Philippine Eagle", maker: svgPhilippineEagle },
      { name: "Sunda Pangolin", maker: svgPangolin },
    ];

    const N = 4, SIZE = N * N;
    const idxToRC = (i) => ({ r: Math.floor(i / N), c: i % N });
    const rcToIdx = (r, c) => r * N + c;

    function isSolvable(arr, emptyIndex) {
      const tiles = arr.filter((x) => x !== -1);
      let inv = 0;
      for (let i = 0; i < tiles.length; i++) for (let j = i + 1; j < tiles.length; j++) if (tiles[i] > tiles[j]) inv++;
      const { r } = idxToRC(emptyIndex); const rowFromBottom = N - r;
      return (inv + rowFromBottom) % 2 === 0;
    }

    function shuffledPositions(blankIndex) {
      let arr = Array.from({ length: SIZE }, (_, i) => i);
      arr[blankIndex] = -1; // exactly one empty
      for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; }
      if (!isSolvable(arr, blankIndex)) { const i = arr.findIndex((x) => x !== -1); const j = arr.findIndex((x, k) => x !== -1 && k !== i); [arr[i], arr[j]] = [arr[j], arr[i]]; }
      return arr;
    }

    function neighborsOfEmpty(state) {
      const ei = state.indexOf(-1); const { r, c } = idxToRC(ei);
      const neigh = []; if (r > 0) neigh.push(rcToIdx(r - 1, c)); if (r < N - 1) neigh.push(rcToIdx(r + 1, c));
      if (c > 0) neigh.push(rcToIdx(r, c - 1)); if (c < N - 1) neigh.push(rcToIdx(r, c + 1)); return { emptyIndex: ei, neigh };
    }

    function isComplete(state) { for (let i = 0; i < SIZE - 1; i++) if (state[i] !== i) return false; return state[SIZE - 1] === -1; }

    function App() {
      const [level, setLevel] = useState(0);
      const [previewMode, setPreviewMode] = useState(true);
      const [imgUrl, setImgUrl] = useState("");
      const [animalName, setAnimalName] = useState("");
      const [state, setState] = useState([]);
      const [startTime, setStartTime] = useState(0);
      const [elapsed, setElapsed] = useState(0);
      const [running, setRunning] = useState(false);
      const [cornerPreview, setCornerPreview] = useState(false);
      const [records, setRecords] = useState(() => {
        const raw = localStorage.getItem("jasons_puzzle_records_v1");
        return raw ? JSON.parse(raw) : [];
      });
      const [showWin, setShowWin] = useState(false);
      const timerRef = useRef(null);
      const dragInfoRef = useRef(null);

      const tileSize = 320, tileStep = tileSize / 4;

      useEffect(() => {
        const a = ANIMALS[level]; setAnimalName(a.name); setImgUrl(toDataUrl(a.maker()));
        setPreviewMode(true); setCornerPreview(false); setRunning(false); setElapsed(0); setState([]);
      }, [level]);

      useEffect(() => {
        if (running) timerRef.current = setInterval(() => setElapsed(Date.now() - startTime), 250);
        else if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [running, startTime]);

      const startLevel = () => {
        const blank = Math.floor(Math.random() * SIZE);
        const arr = shuffledPositions(blank);
        setState(arr); setPreviewMode(false); setCornerPreview(true); setStartTime(Date.now()); setElapsed(0); setRunning(true);
      };

      const moveTile = (tileIndex) => {
        setState((prev) => {
          const { emptyIndex, neigh } = neighborsOfEmpty(prev); if (!neigh.includes(tileIndex)) return prev;
          const next = [...prev]; [next[emptyIndex], next[tileIndex]] = [next[tileIndex], next[emptyIndex]];
          if (isComplete(next)) onWin(); return next;
        });
      };

      const onWin = () => {
        setRunning(false); const timeMs = Date.now() - startTime; setElapsed(timeMs); setShowWin(true); playVictoryMelody();
        const newRecords = [...records]; newRecords[level] = { level: level + 1, name: animalName, ms: timeMs, ts: Date.now() };
        setRecords(newRecords); localStorage.setItem("jasons_puzzle_records_v1", JSON.stringify(newRecords));
      };

      const onPointerDown = (e, i) => {
        if (!state || state.length !== SIZE) return;
        const { neigh } = neighborsOfEmpty(state); if (!neigh.includes(i)) return;
        const el = e.currentTarget; el.setPointerCapture?.(e.pointerId);
        const { emptyIndex } = neighborsOfEmpty(state);
        const dir = (() => { const { r: er, c: ec } = idxToRC(emptyIndex); const { r: tr, c: tc } = idxToRC(i);
          if (er === tr) return ec > tc ? "right" : "left"; if (ec === tc) return er > tr ? "down" : "up"; return null; })();
        if (!dir) return;
        dragInfoRef.current = { startX: e.clientX, startY: e.clientY, dir, i, el, moved: false };
      };

      const onPointerMove = (e) => {
        const info = dragInfoRef.current; if (!info) return;
        const dx = e.clientX - info.startX; const dy = e.clientY - info.startY;
        let tx = 0, ty = 0;
        if (info.dir === "left" || info.dir === "right") tx = Math.max(Math.min(dx, tileStep), -tileStep);
        else if (info.dir === "up" || info.dir === "down") ty = Math.max(Math.min(dy, tileStep), -tileStep);
        info.el.style.transform = `translate(${tx}px, ${ty}px)`; info.moved = Math.abs(tx) + Math.abs(ty) > 4;
      };

      const onPointerUp = (e) => {
        const info = dragInfoRef.current; if (!info) return;
        const matrix = info.el.style.transform; let movedEnough = false;
        if (matrix && matrix.startsWith("translate(")) {
          const vals = matrix.replace("translate(", "").replace(")", "").split(",");
          const tx = parseFloat(vals[0]); const ty = parseFloat(vals[1]);
          if (info.dir === "left" || info.dir === "right") movedEnough = Math.abs(tx) > tileStep/2;
          if (info.dir === "up" || info.dir === "down") movedEnough = Math.abs(ty) > tileStep/2;
        }
        info.el.style.transform = "translate(0px, 0px)";
        if (movedEnough) moveTile(info.i); dragInfoRef.current = null;
      };

      const tiles = useMemo(() => {
        if (!imgUrl || state.length !== SIZE) return [];
        const positions = []; for (let i = 0; i < SIZE; i++) { const row = Math.floor(i / N); const col = i % N;
          const bgX = (col / (N - 1)) * 100; const bgY = (row / (N - 1)) * 100; positions.push({ bgX, bgY }); }
        return state.map((tile, i) => { if (tile === -1) return { i, tile, empty: true }; const { bgX, bgY } = positions[tile]; return { i, tile, empty: false, bgX, bgY }; });
      }, [imgUrl, state]);

      return (
        <div className="min-h-screen w-full bg-gradient-to-b from-slate-100 to-white text-slate-800"
             onPointerMove={onPointerMove} onPointerUp={onPointerUp} onPointerCancel={onPointerUp}>
          <header className="flex items-center justify-between px-6 py-4 border-b border-slate-200 bg-white/70 backdrop-blur sticky top-0 z-20">
            <div className="flex items-baseline gap-3">
              <h1 className="text-2xl md:text-3xl font-extrabold tracking-tight">Jason's 4x4 Puzzle</h1>
              <span className="text-xs md:text-sm px-2 py-0.5 rounded-full bg-slate-800 text-white">2025</span>
            </div>
            <div className="text-sm">
              Level <span className="font-semibold">{/* current level */} {1 + (state.length ? 0 : 0)}</span>/10 · { (running || (!previewMode && state.length===SIZE)) ? <span className="tabular-nums">{fmtTime(elapsed)}</span> : "00:00" }
            </div>
          </header>

          <main className="max-w-5xl mx-auto px-4 pb-24 pt-6">
            {cornerPreview && (
              <div className="fixed right-4 bottom-4 z-10 select-none">
                <div className="bg-white rounded-2xl shadow-lg p-2 border border-slate-200">
                  <div className="w-28 h-28 rounded-xl overflow-hidden">
                    <img src={imgUrl} alt={animalName} className="w-full h-full object-cover"/>
                  </div>
                  <div className="text-center text-xs mt-1 text-slate-600">{animalName}</div>
                </div>
              </div>
            )}

            {previewMode && (
              <div className="grid md:grid-cols-2 gap-8 items-center">
                <div className="rounded-3xl overflow-hidden bg-white shadow-lg border border-slate-200">
                  <img src={imgUrl} alt={animalName} className="w-full h-[360px] object-cover"/>
                </div>
                <div>
                  <h2 className="text-3xl font-bold mb-2">Level {1}: {animalName}</h2>
                  <p className="text-slate-600 mb-6">시작을 누르면 그림이 모서리에 미니맵으로 보입니다. 빈 칸은 매판 랜덤이며, 인접 조각을 드래그/탭으로 이동하세요.</p>
                  <button onClick={startLevel} className="px-5 py-3 rounded-xl bg-slate-800 text-white font-semibold shadow hover:shadow-md active:scale-[0.98]">Start Puzzle</button>
                </div>
              </div>
            )}

            {!previewMode && (
              <div className="flex flex-col items-center gap-4">
                <div className="text-slate-600">드래그 또는 탭으로 인접 조각을 이동할 수 있습니다.</div>
                <div className="relative grid grid-cols-4 grid-rows-4 bg-white rounded-3xl p-0 shadow-lg border border-slate-200 select-none gap-0 overflow-hidden"
                     style={{ width: 320, height: 320 }}>
                  {tiles.map((t) => (
                    <div key={t.i}
                      className={"rounded-none " + (t.empty ? "bg-white" : "bg-transparent")}
                      style={{
                        width: 320 / 4, height: 320 / 4,
                        backgroundImage: t.empty ? "none" : `url(${imgUrl})`,
                        backgroundSize: "400% 400%",
                        backgroundPosition: t.empty ? undefined : `${t.bgX}% ${t.bgY}%`,
                        backgroundRepeat: "no-repeat",
                        touchAction: "none",
                        transition: "transform 120ms ease",
                        cursor: t.empty ? "default" : "grab",
                        boxShadow: t.empty ? "inset 0 0 0 2px rgba(15,23,42,0.2)" : "none",
                      }}
                      onClick={() => !t.empty && moveTile(t.i)}
                      onPointerDown={(e) => onPointerDown(e, t.i)}
                    />
                  ))}
                </div>
                <div className="text-sm text-slate-500">빈 칸은 항상 **한 칸**만 존재합니다. 모든 조각이 맞춰지면 클리어!</div>
              </div>
            )}
          </main>

          {showWin && (
            <div className="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center z-30" onClick={() => setShowWin(false)}>
              <div className="bg-white rounded-3xl shadow-xl border border-slate-200 max-w-xl w-[92vw] p-4" onClick={(e)=>e.stopPropagation()}>
                <div className="rounded-2xl overflow-hidden mb-3">
                  <img src={imgUrl} alt={animalName} className="w-full h-[280px] object-cover"/>
                </div>
                <h3 className="text-xl font-bold mb-1">Clear — {animalName}</h3>
                <p className="text-slate-600 mb-4">기록: <span className="font-semibold tabular-nums">{fmtTime(elapsed)}</span></p>
                <div className="flex items-center gap-2 justify-end">
                  <button onClick={() => { setShowWin(false); location.reload(); }} className="px-4 py-2 rounded-xl bg-slate-800 text-white font-semibold">다음 레벨</button>
                </div>
              </div>
            </div>
          )}

          <footer className="text-center text-xs text-slate-500 py-10">© 2025 Jason — Sliding Puzzle built with love.</footer>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
